/////////////////////////////////////////////////////////////////////////////// 
//Перем NodeS, EdgeS;
Функция ПолучитьНомерВерсииОбработки() Экспорт
	
	Возврат "1.0.1";
	
КонецФункции



///////////////////////////////////////////////////////////////////////////////
// Построение дерева функций

Процедура ПостроитьДеревоФункций(ДеревоФункций) Экспорт
	
	ДеревоФункций.Строки.Очистить();
	
	Если ТипОтчета = 0 Тогда
		ПостроитьДеревоФункцийОбщийСписок(ДеревоФункций);
	ИначеЕсли ТипОтчета = 1 Тогда
		ПостроитьДеревоФункцийПоСекциям(ДеревоФункций);
	ИначеЕсли ТипОтчета = 2 Тогда
		ПостроитьДеревоФункцийДляУправляемойФормы(ДеревоФункций, Ложь);
	ИначеЕсли ТипОтчета = 3 Тогда
		ПостроитьДеревоФункцийДляУправляемойФормы(ДеревоФункций, Истина);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПостроитьДеревоФункцийОбщийСписок(ДеревоФункций)
	
	масСтрок = Новый Массив;
	Для Каждого Стр Из Функции Цикл
		Если Стр.НомерСекции <> 0 И ИсключаемыеФункций.НайтиПоЗначению(Стр.Идентификатор) = Неопределено Тогда
			масСтрок.Добавить(Стр);
		КонецЕсли;
	КонецЦикла;
	
	Если ПоКомпонентамСвязности Тогда
		ЗаполнитьСписокПоКомпонентамСвязности(ДеревоФункций, масСтрок, Истина);
	Иначе
		ЗаполнитьСписокФункций(ДеревоФункций, масСтрок);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьСписокФункций(ДеревоФункций, масСтрок)
	
	ИДСтроки = 0;
	Для Каждого Стр Из масСтрок Цикл
		ИДСтроки = ИДСтроки + 1;
		ДобавитьФункциюВДерево(ДеревоФункций, Стр, ИДСтроки);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьСписокПоКомпонентамСвязности(ДеревоФункций, масСтрок, ИсключатьЕдиничные)
	
	// Получим сначала таблицу связей
	табСвязи = Вызовы.Выгрузить(, "ИзФункции,Функцию");
	табСвязи.Свернуть("ИзФункции,Функцию");
	
	// Создадим таблицу для компонент
	Компоненты = Новый ТаблицаЗначений;
	Компоненты.Колонки.Добавить("Элементы");
	Компоненты.Колонки.Добавить("Количество");
	Компоненты.Колонки.Добавить("НомерСтрокиВТексте");
	Для Каждого Стр Из масСтрок Цикл
		новСтр = Компоненты.Добавить();
		новСтр.Элементы = Новый Соответствие;
		новСтр.Элементы.Вставить(Стр.Идентификатор, Стр);
		новСтр.Количество = 1;
		новСтр.НомерСтрокиВТексте = Стр.НомерСтрокиВТексте;
	КонецЦикла;
	
	// Пройдем по таблице связей соединим все в компоненты
	Для Каждого СтрСвязь Из табСвязи Цикл
		
		СтрИз = НайтиФункциюВКомпонентах(Компоненты, СтрСвязь.ИзФункции);
		Если СтрИз = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СтрВ = НайтиФункциюВКомпонентах(Компоненты, СтрСвязь.Функцию);
		Если СтрВ = Неопределено Или СтрИз = СтрВ Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого Элемент Из СтрВ.Элементы Цикл
			СтрИз.Элементы.Вставить(Элемент.Ключ, Элемент.Значение);
		КонецЦикла;
		СтрИз.Количество = СтрИз.Элементы.Количество();
		СтрИз.НомерСтрокиВТексте = Мин(СтрИз.НомерСтрокиВТексте, СтрВ.НомерСтрокиВТексте);
		Компоненты.Удалить(СтрВ);
		
	КонецЦикла;
	
	// Подсчитаем количества и удалим компоненты состоящие из одного элемента
	Если ИсключатьЕдиничные Тогда
		масУдалять = Новый Массив;
		Для Каждого Стр Из Компоненты Цикл
			Стр.Количество = Стр.Элементы.Количество();
			Если Стр.Количество = 1 Тогда
				масУдалять.Добавить(Стр);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого Стр Из масУдалять Цикл
			Компоненты.Удалить(Стр);
		КонецЦикла;
	КонецЕсли;
	
	// Теперь выведем результат в дерево
	ИДСтроки = 0;
	Компоненты.Сортировать("Количество Убыв, НомерСтрокиВТексте");
	Для Каждого СтрК Из Компоненты Цикл
		Если СтрК.Количество = 1 Тогда
			Для Каждого Элемент Из СтрК.Элементы Цикл
				ИДСтроки = ИДСтроки + 1;
				ДобавитьФункциюВДерево(ДеревоФункций, Элемент.Значение, ИДСтроки);
			КонецЦикла;
			Продолжить;
		КонецЕсли;
		
		ИДСтроки = ИДСтроки + 1;
		новСтрК = ДеревоФункций.Строки.Добавить();
		новСтрК.ИДСтроки = ИДСтроки;
		Для Каждого Элемент Из СтрК.Элементы Цикл
			ИДСтроки = ИДСтроки + 1;
			новСтрФ = ДобавитьФункциюВДерево(новСтрК, Элемент.Значение, ИДСтроки);
			новСтрК.Проблемная82 = новСтрК.Проблемная82 Или новСтрФ.Проблемная82;
		КонецЦикла;
		новСтрК.Строки.Сортировать("НомерСтрокиВТексте");
		новСтрК.ИмяФункции = "(" + СтрК.Элементы.Количество() + ") " + новСтрК.Строки[0].ИмяФункции + ", ...";
		новСтрК.ЭтоФункция = 2;	// Картинка для компоненты
	КонецЦикла;
	
КонецПроцедуры

Функция НайтиФункциюВКомпонентах(Компоненты, Идентификатор)
	
	Для Каждого Стр Из Компоненты Цикл
		Если Стр.Элементы.Получить(Идентификатор) <> Неопределено Тогда
			Возврат Стр;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Процедура ПостроитьДеревоФункцийПоСекциям(ДеревоФункций)
	
	ИДСтроки = 0;
	
	// Заполним сначала секции
	соотвНомеровСекций = Новый Соответствие;
	Для Каждого Стр Из Секции Цикл
		ИДСтроки = ИДСтроки + 1;
		новСтр = ДеревоФункций.Строки.Добавить();
		новСтр.ИмяФункции = Стр.ИмяСекции;
		новСтр.НомерСтрокиВТексте = Стр.НомерСтрокиВТексте;
		новСтр.НомерСекции = Стр.НомерСекции;
		новСтр.ИДСтроки = ИДСтроки;
		соотвНомеровСекций.Вставить(Стр.НомерСекции, новСтр);
	КонецЦикла;
	
	// Добавим функции
	Для Каждого Стр Из Функции Цикл
		Если Стр.НомерСекции <> 0 Тогда
			ИДСтроки = ИДСтроки + 1;
			ДобавитьФункциюВДерево(соотвНомеровСекций.Получить(Стр.НомерСекции), Стр, ИДСтроки);
		КонецЕсли;
	КонецЦикла;
	
	// Заполним флажки в секциях
	Для Каждого Стр Из ДеревоФункций.Строки Цикл
		Есть0 = Ложь;
		Есть1 = Ложь;
		Для Каждого СтрФ Из Стр.Строки Цикл
			Если СтрФ.Выбран = 0 Тогда
				Есть0 = Истина;
			Иначе
				Есть1 = Истина;
			КонецЕсли;
		КонецЦикла;
		
		Если Не Есть1 Тогда
			Стр.Выбран = 0;
		ИначеЕсли Есть0 Тогда
			Стр.Выбран = 2;
		Иначе
			Стр.Выбран = 1;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ДобавитьФункциюВДерево(КудаДобавлять, СтрокаФункции, ИДСтроки)
	
	новСтр = КудаДобавлять.Строки.Добавить();
	ЗаполнитьЗначенияСвойств(новСтр, СтрокаФункции);
	новСтр.ИДСтроки = ИДСтроки;
	новСтр.Выбран   = ?(ИсключаемыеФункций.НайтиПоЗначению(СтрокаФункции.Идентификатор) = Неопределено, 1, 0);
	
	Возврат новСтр;
	
КонецФункции

Процедура ПостроитьДеревоФункцийДляУправляемойФормы(ДеревоФункций, ТолькоПриводящиеКВызовуНаСервер)
	
	// Найдем секцию
	СтрДирективы = Директивы.Найти("&НаКлиенте", "ОписаниеДирективы");
	Если СтрДирективы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	масСтрок = Новый Массив;
	Для Каждого Стр Из Функции Цикл
		Если Стр.Директива = СтрДирективы.НомерДирективы Тогда
			Если Стр.ПриводитКВызовуНаСервер Или Не ТолькоПриводящиеКВызовуНаСервер Тогда
				масСтрок.Добавить(Стр);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ПоКомпонентамСвязности Тогда
		ЗаполнитьСписокПоКомпонентамСвязности(ДеревоФункций, масСтрок, Ложь);
	Иначе
		ЗаполнитьСписокФункций(ДеревоФункций, масСтрок);
	КонецЕсли;
	
КонецПроцедуры



///////////////////////////////////////////////////////////////////////////////
// Построение графа

Функция ПодготовитьПостроениеГрафа(ДеревоФункций, ИДСтроки) Экспорт
		ТекстГрафа = "";
	Структура_GML = Новый Структура;

	Если ТипОтчета = 1 И ТипОтчетаПоСекциям = 1 Тогда
		Возврат ПодготовитьПостроениеГрафаВызовыМеждуСекциями(ДеревоФункций, Структура_GML);
	КонецЕсли;
	
	// Найдем строку
	текСтр = ДеревоФункций.Строки.Найти(ИДСтроки, "ИДСтроки", Истина);
	Если текСтр = Неопределено Тогда
		Возврат "Не найдена строка!";
	КонецЕсли;
	
	// Определим, выбрана функция или группа
	ВыбранаФункция   = Ложь;
	ВыбраннаяФункция = "";
	Если текСтр.Строки.Количество() = 0 И ИсключаемыеФункций.НайтиПоЗначению(текСтр.Идентификатор) = Неопределено Тогда
		ВыбранаФункция   = Истина;
		ВыбраннаяФункция = текСтр.Идентификатор;
	ИначеЕсли ТипОтчетаПоФункции > 0 Тогда
		Возврат "Не выбрана функция или процедура!";
	КонецЕсли;
	
	// Определим направления построения графа от функций и начальный список функций
	СтроитьВверх  = Истина;
	СтроитьВниз   = Истина;
	СписокФункций = ОпределитьСоставФункций(ДеревоФункций, текСтр, СтроитьВверх, СтроитьВниз);
	Если СписокФункций.Количество() = 0 Тогда
		Возврат "Не выбрано ни одной функции и процедуры!";
	КонецЕсли;
	СтроитьВверхНаКоторыхОстанавливаться = СтроитьВверх;
	СтроитьВнизНаКоторыхОстанавливаться  = СтроитьВниз;
	
	// Определим список функций, на которых нужно останавливать построение графа
	Если ТипОтчета = 1 И ТипОтчетаПоСекциям = 2 Тогда
		// Получим список всех функций, не входящих в выбранную секцию
		ФункцииНаКоторыхОстанавливаться = ОпределитьФункцииНеВходящиеВТекущуюСекцию(ДеревоФункций, текСтр);
		Если Не ОтображатьОбращенияКСекции Тогда
			СтроитьВверхНаКоторыхОстанавливаться = Ложь;
		КонецЕсли;
		Если Не ОтображатьОбращенияИзСекции Тогда
			СтроитьВнизНаКоторыхОстанавливаться = Ложь;
		КонецЕсли;
	Иначе
		ФункцииНаКоторыхОстанавливаться = ОпределитьФункцииНаКоторыхОстанавливатьПостроениеГрафа();
	КонецЕсли;
	
	// Составим список всех функций и вызовов
	СписокВызовов = НайтиВсеФункцииИВызовы(СписокФункций, СтроитьВверх, СтроитьВниз, ФункцииНаКоторыхОстанавливаться, СтроитьВверхНаКоторыхОстанавливаться, СтроитьВнизНаКоторыхОстанавливаться);
	
	// Выведем информацию о функциях
	ДеревоПоКластерам = ПолучитьДеревоФункцийПоКластерам(СписокФункций);
	
	// Создаем текст на языек GML
	ИдентификаторыФункций = Неопределено;
	
	
	СозданиеМассивовТекстВГрафаВ_GML(ВыбраннаяФункция, ДеревоПоКластерам, СписокВызовов, ИдентификаторыФункций, Структура_GML);
	
	Результат = ЗавершитьПостроениеГрафа(ИдентификаторыФункций, Структура_GML, ТекстГрафа);
	
	Возврат Результат;
	
КонецФункции

Функция ЗавершитьПостроениеГрафа(Знач ИдентификаторыФункций, Знач Структура_GML, ТекстГрафа)
	
	Перем Результат;
	
	// Завершим вывод текста графа
	СтруктураВ_GMLТекст(ТекстГрафа, "graph", Структура_GML);	
	
	
	// Возвращаем текст на языеке GML
	Результат = Новый Структура;
	Результат.Вставить("ТекстГрафа", ТекстГрафа);
	Результат.Вставить("ИдентификаторыФункций", ИдентификаторыФункций);
	Возврат Результат;

КонецФункции

Процедура   СозданиеМассивовТекстВГрафаВ_GML(Знач ВыбраннаяФункция, Знач ДеревоПоКластерам, Знач СписокВызовов, ИдентификаторыФункций, Структура_GML)
	// Начнем вывод текста графа
	Перем НомерКластера;
	Перем EdgeS;
    Перем Node_ID;
    Перем NodeS;
    Перем спсИдентификаторы;
	
    ИнициализацияСозданиеМассивовТекстВГрафаВ_GML(ИдентификаторыФункций, EdgeS, Node_ID, NodeS, спсИдентификаторы);
	
	Для Каждого СтрКластер Из ДеревоПоКластерам.Строки Цикл
		ЕстьКластер = (СтрКластер.СтрокаВТаблице <> Неопределено);
		Если ЕстьКластер Тогда
			Node=NodeS.Добавить();
			Node.id = Node_ID;
			Node.label= """"+ ?(ТипОтчета = 1,СтрКластер.СтрокаВТаблице.ИмяСекции,СтрКластер.СтрокаВТаблице.ОписаниеДирективы) + """" ;
			Node.graphics= Новый Структура;
			Node.graphics.Вставить("type","""roundrectangle""");
			Node.graphics.Вставить("hasFill","0");
			Node.graphics.Вставить("outline","""#0000FF""");
			Node.graphics.Вставить("outlineStyle","""dashed""");
			Node.LabelGraphics= Новый Структура;
			//Node.LabelGraphics.Вставить("fontSize",);
			Node.LabelGraphics.Вставить("anchor","""t""");
			Node.isGroup= "1";
			//Node.Кластер= СтрКластер;
			Node_GID = Node_ID;
			Node_ID=Node_ID+1;
		КонецЕсли;
		
		Для Каждого СтрФ Из СтрКластер.Строки Цикл
			Инфо = СтрФ.СтрокаВТаблице;
			Node=NodeS.Добавить();
			Node.id = Node_ID;
			Node.label= """"+ ?(ОтображатьТолькоИдентификаторы,Инфо.Идентификатор, Инфо.ИмяФункции) + """" ;
			Node.graphics= Новый Структура;
			Node.graphics.Вставить("type",?(Инфо.ЭтоФункция, """ellipse""", """rectangle"""));
			Node.graphics.Вставить("fill",?(Инфо.Экспортная, """#CCFFCC""", """#CCFFFF"""));
			Node.graphics.Вставить("outline",?(Инфо.Идентификатор = ВыбраннаяФункция,"""#FF0000""","""#000000"""));
			Node.ФункцияИлиПроцедура= Инфо.Идентификатор;
			Если ЕстьКластер Тогда
				Node.gid = Node_GID;
			КонецЕсли;
			Node_ID=Node_ID+1;
			спсИдентификаторы.Добавить(Инфо.Идентификатор, Инфо.ИмяФункции);
		КонецЦикла;
	КонецЦикла;
	
	// Сформируем строку с идентификаторами
	спсИдентификаторы.СортироватьПоЗначению();
	Для Каждого Элемент Из спсИдентификаторы Цикл
		ИдентификаторыФункций = ""+ИдентификаторыФункций + Элемент.Значение + " " + Элемент.Представление + Символы.ПС;
	КонецЦикла;
	
	// Выведем информацию о вызовах
	Для Каждого Элемент Из СписокВызовов Цикл
		СтрВызова = Элемент.Ключ;
		Edge=EdgeS.Добавить();
		Edge.source = nodes.Найти(СтрВызова.ИзФункции,"ФункцияИлиПроцедура").ID;
		Edge.target = nodes.Найти(СтрВызова.Функцию,"ФункцияИлиПроцедура").ID;
		Edge.label= """"+  Строка(СтрВызова.Количество) + """" ;
		Edge.graphics= Новый Структура;
		Если СтрВызова.ВложенностьЦикла > 0 Тогда
			Edge.graphics.Вставить("fill","""#FF0000""");
		ИначеЕсли 		СтрВызова.Количество > 1 Тогда
			Edge.graphics.Вставить("fill","""#0000FF""");
		Иначе
			Edge.graphics.Вставить("fill","""#000000""");
		КонецЕсли;
		Edge.graphics.Вставить("targetArrow", """standard""");
		Edge.LabelGraphics= Новый Структура;
		Edge.LabelGraphics.Вставить( "anchor","""c""");
	КонецЦикла;
	
	Структура_GML.Вставить("NodeS", NodeS);
	Структура_GML.Вставить("EdgeS", EdgeS);
КонецПроцедуры

Процедура ИнициализацияСозданиеМассивовТекстВГрафаВ_GML(ИдентификаторыФункций, EdgeS, Node_ID, NodeS, спсИдентификаторы)
	
	Перем Node_GID, ЕстьКластер, СтрКластер;
	
	EdgeS = Неопределено;
	NodeS = Неопределено;
	спсИдентификаторы = Неопределено;
	СтрКластер = Неопределено;
	ЕстьКластер = Неопределено;
	Node_ID=0;
	Node_GID=0;
	ИдентификаторыФункций = "";
	спсИдентификаторы = Новый СписокЗначений;
	
	NodeS = Новый ТаблицаЗначений;
	NodeS.Колонки.Добавить("ФункцияИлиПроцедура");
	NodeS.Колонки.Добавить("id");
	NodeS.Колонки.Добавить("label");
	NodeS.Колонки.Добавить("graphics");
	NodeS.Колонки.Добавить("LabelGraphics");
	NodeS.Колонки.Добавить("isGroup");
	NodeS.Колонки.Добавить("gid");
	//NodeS.Колонки.Добавить("Кластер");
	
	EdgeS = Новый ТаблицаЗначений;
	EdgeS.Колонки.Добавить("Связь");
	EdgeS.Колонки.Добавить("source");
	EdgeS.Колонки.Добавить("target");
	EdgeS.Колонки.Добавить("label");
	EdgeS.Колонки.Добавить("graphics");
	EdgeS.Колонки.Добавить("LabelGraphics");

КонецПроцедуры

Функция СтруктураВ_GMLТекст(ТекстГрафа, Имя, Значение)
	//Проверяем тип параметра
	Если	типЗнч(Значение)= тип("Строка") Или типЗнч(Значение)= тип("Число") Тогда
		ТекстГрафа = ТекстГрафа +Символы.ПС+ Символы.Таб +Имя+ " "+ Значение ;
	ИначеЕсли типЗнч(Значение)= тип("Структура") Тогда
		//Добавляем имя параметра
		ТекстГрафа = ТекстГрафа+Имя+Символы.ПС;
		//Открываем блок
		ТекстГрафа = ТекстГрафа+ "[";	
		Для Каждого Элемент Из Значение Цикл
			//Добавляем значения
			ТекстГрафа = СтруктураВ_GMLТекст(ТекстГрафа, Элемент.Ключ, Элемент.Значение);
		КонецЦикла;	
		//Закрываем блок
		ТекстГрафа = ТекстГрафа + Символы.ПС + "]";
	ИначеЕсли типЗнч(Значение)= тип ("ТаблицаЗначений") Тогда
		//Разбор таблицы
		Для Каждого ТекущаяСтрока Из Значение Цикл                // перебор строк
			Для Каждого ТекущаяКолонка Из Значение.Колонки Цикл     // перебор столбцов
				Если ТекущаяКолонка.Имя = "ФункцияИлиПроцедура" Тогда
						ТекстГрафа = ТекстГрафа +Символы.ПС +"node"+ Символы.Таб + "[";
				ИначеЕсли ТекущаяКолонка.Имя = "Связь" Тогда
						ТекстГрафа = ТекстГрафа +Символы.ПС +"edge"+ Символы.Таб + "[";
				ИначеЕсли типЗнч(ТекущаяСтрока[ТекущаяКолонка.Имя])= тип("Структура")  Тогда 
					ТекстГрафа = СтруктураВ_GMLТекст(ТекстГрафа+Символы.ПС, ТекущаяКолонка.Имя, ТекущаяСтрока[ТекущаяКолонка.Имя]);	
				ИначеЕсли  типЗнч(ТекущаяСтрока[ТекущаяКолонка.Имя])= тип("Строка") Или типЗнч(ТекущаяСтрока[ТекущаяКолонка.Имя])= тип("Число") Тогда // добавляем непустые значения    <> Неопределено  
					ТекстГрафа = ТекстГрафа+Символы.ПС+ ТекущаяКолонка.Имя  + " " + ТекущаяСтрока[ТекущаяКолонка.Имя] ;
				КонецЕсли;
			КонецЦикла;
		ТекстГрафа = ТекстГрафа + Символы.Таб +"]";
		КонецЦикла;  
	КонецЕсли;	
	Возврат ТекстГрафа;
КонецФункции

Функция ОпределитьСоставФункций(ДеревоФункций, ТекущаяСтрока, СтроитьВверх, СтроитьВниз)
	
	НачальныйСписок = Новый Соответствие;
	
	// Случай, когда установлен тип отчета по функции
	Если ТипОтчетаПоФункции = 1 Тогда
		СтроитьВниз = Ложь;
		ДобавитьВСписокФункцию(НачальныйСписок, ТекущаяСтрока.Идентификатор);
		Возврат НачальныйСписок;
	ИначеЕсли ТипОтчетаПоФункции = 2 Тогда
		СтроитьВверх = Ложь;
		ДобавитьВСписокФункцию(НачальныйСписок, ТекущаяСтрока.Идентификатор);
		Возврат НачальныйСписок;
	КонецЕсли;
	
	Если ТипОтчета = 1 Тогда
		Если ТипОтчетаПоСекциям = 0 Тогда
			// Добавляем вообще все функции
			Для Каждого СтрГруппы Из ДеревоФункций.Строки Цикл
				ДобавитьВСписокФункцииГруппы(НачальныйСписок, СтрГруппы);
			КонецЦикла;
		Иначе
			// Добавляем функции из текущей группы
			СтрГруппы = ?(ТекущаяСтрока.Родитель = Неопределено, ТекущаяСтрока, ТекущаяСтрока.Родитель);
			ДобавитьВСписокФункцииГруппы(НачальныйСписок, СтрГруппы);
		КонецЕсли;
		
		Возврат НачальныйСписок;
	КонецЕсли;
	
	Если ТипОтчета > 1 И ПоКомпонентамСвязности Тогда
		СтроитьВверх = Ложь;
	КонецЕсли;
	
	Если Не ПоКомпонентамСвязности Тогда
		// Если не по компонентам связности, то берем все строки
		Для Каждого Стр Из ДеревоФункций.Строки Цикл
			ДобавитьВСписокФункцию(НачальныйСписок, Стр.Идентификатор);
		КонецЦикла;
		
		Возврат НачальныйСписок;
	КонецЕсли;
		
	СтрГруппы = ?(ТекущаяСтрока.Родитель = Неопределено, ТекущаяСтрока, ТекущаяСтрока.Родитель);
	ДобавитьВСписокФункцииГруппы(НачальныйСписок, СтрГруппы);
	
	Возврат НачальныйСписок;
	
КонецФункции

Функция ОпределитьФункцииНеВходящиеВТекущуюСекцию(ДеревоФункций, ТекущаяСтрока)
	
	Результат = Новый Соответствие;
	текСекция = ?(ТекущаяСтрока.Родитель = Неопределено, ТекущаяСтрока, ТекущаяСтрока.Родитель);
	
	Для Каждого СтрСекция Из ДеревоФункций.Строки Цикл
		Если СтрСекция <> текСекция Тогда
			Для Каждого Стр Из СтрСекция.Строки Цикл
				Результат.Вставить(Стр.Идентификатор, Истина);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ДобавитьВСписокФункцииГруппы(НачальныйСписок, СтрГруппы)
	
	Если СтрГруппы.Строки.Количество() = 0 Тогда
		ДобавитьВСписокФункцию(НачальныйСписок, СтрГруппы.Идентификатор);
	Иначе
		Для Каждого Стр Из СтрГруппы.Строки Цикл
			ДобавитьВСписокФункцию(НачальныйСписок, Стр.Идентификатор);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьВСписокФункцию(НачальныйСписок, Идентификатор)
	
	Если ИсключаемыеФункций.НайтиПоЗначению(Идентификатор) = Неопределено Тогда
		НачальныйСписок.Вставить(Идентификатор, Истина);
	КонецЕсли;
	
КонецПроцедуры

Функция ОпределитьФункцииНаКоторыхОстанавливатьПостроениеГрафа()
	
	Результат = Новый Соответствие;
	Если ТипОтчета < 2 Или Не ТолькоПервыеВызовыНаСервере Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Определим какие директивы приводят к вызову на сервер
	соотвДирективы = Новый Соответствие;
	Для Каждого СтрД Из Директивы Цикл
		Если СтрД.ОстанавливатьПоиск Тогда
			соотвДирективы.Вставить(СтрД.НомерДирективы, Истина);
		КонецЕсли;
	КонецЦикла;
	
	// Получим список серверных функций
	Для Каждого СтрФ Из Функции Цикл
		Если соотвДирективы.Получить(СтрФ.Директива) = Истина Тогда
			Результат.Вставить(СтрФ.Идентификатор, Истина);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция НайтиВсеФункцииИВызовы(СписокФункций, СтроитьВверх, СтроитьВниз, ФункцииНаКоторыхОстанавливаться, СтроитьВверхНаКоторыхОстанавливаться, СтроитьВнизНаКоторыхОстанавливаться)
	
	СписокВызовов = Новый Соответствие;
	БылиИзменения = Истина;
	
	Пока БылиИзменения Цикл
		БылиИзменения = Ложь;
		
		// Переберем все вызовы
		Для Каждого СтрВызов Из Вызовы Цикл
			Если СписокВызовов.Получить(СтрВызов) = Истина Тогда
				Продолжить;
			КонецЕсли;
			
			Если СтроитьВверх Тогда
				ДобавитьФункциюИВызов(СписокФункций, СписокВызовов, ФункцииНаКоторыхОстанавливаться, СтрВызов, СтрВызов.ИзФункции, СтрВызов.Функцию, БылиИзменения, СтроитьВверхНаКоторыхОстанавливаться);
			КонецЕсли;
			
			Если СтроитьВниз Тогда
				ДобавитьФункциюИВызов(СписокФункций, СписокВызовов, ФункцииНаКоторыхОстанавливаться, СтрВызов, СтрВызов.Функцию, СтрВызов.ИзФункции, БылиИзменения, СтроитьВнизНаКоторыхОстанавливаться);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат СписокВызовов;
	
КонецФункции

Процедура ДобавитьФункциюИВызов(СписокФункций, СписокВызовов, ФункцииНаКоторыхОстанавливаться, СтрВызов, ПерваяФункция, ВтораяФункция, БылиИзменения, ПродолжатьПостроениеДоФункцииНаКоторыхОстанавливаться)
	
	Если СписокФункций.Получить(ВтораяФункция) <> Истина Тогда
		Возврат;
	ИначеЕсли ФункцииНаКоторыхОстанавливаться.Получить(ВтораяФункция) = Истина Тогда
		Возврат;
	ИначеЕсли ИсключаемыеФункций.НайтиПоЗначению(ПерваяФункция) <> Неопределено Тогда
		Возврат;
	ИначеЕсли Не ПродолжатьПостроениеДоФункцииНаКоторыхОстанавливаться И ФункцииНаКоторыхОстанавливаться.Получить(ПерваяФункция) = Истина Тогда
		Возврат;
	КонецЕсли;
	
	СтрФ = Функции.Найти(ПерваяФункция, "Идентификатор");
	Если ТипОтчета = 3 И Не СтрФ.ПриводитКВызовуНаСервер Тогда
		Возврат;
	ИначеЕсли ТипОтчета <= 1 И СтрФ.НомерСекции = 0 Тогда
		Возврат;
	КонецЕсли;
	
	СписокВызовов.Вставить(СтрВызов, Истина);
	Если СписокФункций.Получить(ПерваяФункция) = Неопределено Тогда
		СписокФункций.Вставить(ПерваяФункция, Истина);
		БылиИзменения = Истина;
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьДеревоФункцийПоКластерам(СписокФункций)
	
	ДеревоПоКластерам = Новый ДеревоЗначений;
	ДеревоПоКластерам.Колонки.Добавить("СтрокаВТаблице");
	
	Для Каждого Элемент Из СписокФункций Цикл
		
		СтрокаВТаблице = Функции.Найти(Элемент.Ключ, "Идентификатор");
		
		// Определим кластер, в котором должна быть эта функция
		СтрокаКластераВТаблице = Неопределено;
		Если ТипОтчета > 1 Тогда
			СтрДирективы = Директивы.Найти(СтрокаВТаблице.Директива, "НомерДирективы");
			Если СтрДирективы <> Неопределено Тогда
				Если СтрДирективы.ОписаниеДирективы <> "&НаКлиенте" Или НаКлиентеВОдномКластере Тогда
					СтрокаКластераВТаблице = СтрДирективы;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ТипОтчета = 1 Тогда
			СтрокаКластераВТаблице = Секции.Найти(СтрокаВТаблице.НомерСекции, "НомерСекции");
		КонецЕсли;
		
		
		СтрКластера = Неопределено;
		Для Каждого СтрК Из ДеревоПоКластерам.Строки Цикл
			Если СтрК.СтрокаВТаблице = СтрокаКластераВТаблице Тогда
				СтрКластера = СтрК;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если СтрКластера = Неопределено Тогда
			СтрКластера = ДеревоПоКластерам.Строки.Добавить();
			СтрКластера.СтрокаВТаблице = СтрокаКластераВТаблице;
		КонецЕсли;
		
		новСтр = СтрКластера.Строки.Добавить();
		новСтр.СтрокаВТаблице = СтрокаВТаблице;
		
	КонецЦикла;
	
	Возврат ДеревоПоКластерам;
	
КонецФункции

Функция ПодготовитьПостроениеГрафаВызовыМеждуСекциями(ДеревоФункций, Структура_GML)
	Перем НомерКластера;
	Перем EdgeS;
    Перем Node_ID;
    Перем NodeS;
    Перем спсИдентификаторы;
	ИдентификаторыФункций = Неопределено;
	ТекстГрафа = "";

	// Получим список функций
	СоответствиеФункций = СписокФункцийПостроениеГрафаВызовыМеждуСекциями(ДеревоФункций);
	
	Если СоответствиеФункций.Количество() = 0 Тогда
		Возврат "Не выбрано ни одной функции и процедуры!";
	КонецЕсли;
	
	// Составим таблицу вызовов между секциями
	ТабВызовы = ТаблицаВызововПостроениеГрафаВызовыМеждуСекциями(СоответствиеФункций);
	
    ИнициализацияСозданиеМассивовТекстВГрафаВ_GML(ИдентификаторыФункций, EdgeS, Node_ID, NodeS, спсИдентификаторы);

	соотвСекции = Новый Соответствие;
	Для Каждого Стр Из ТабВызовы Цикл
		
		Edge=EdgeS.Добавить();
		Edge.source = Стр.ИзСекции;
		Edge.target = Стр.Секцию;
		Edge.label= """"+  Строка(Стр.Количество) + """" ;
		Edge.graphics= Новый Структура;
		Если Стр.ВложенностьЦикла  > 0 Тогда
			Edge.graphics.Вставить("fill","""#FF0000""");
		ИначеЕсли 		Стр.Количество > 1 Тогда
			Edge.graphics.Вставить("fill","""#0000FF""");
		Иначе
			Edge.graphics.Вставить("fill","""#000000""");
		КонецЕсли;
		Edge.graphics.Вставить("targetArrow", """standard""");
		Edge.LabelGraphics= Новый Структура;
		Edge.LabelGraphics.Вставить( "anchor","""c""");

		соотвСекции.Вставить(Стр.ИзСекции, Истина);
		соотвСекции.Вставить(Стр.Секцию,   Истина);
	КонецЦикла;
	
	Для Каждого Элемент Из соотвСекции Цикл
		Секция = Элемент.Ключ;
		СтрСекции = Секции.Найти(Секция, "НомерСекции");
	
			Node=NodeS.Добавить();
			Node.id = Секция;
			Node.label= """"+ ПолучитьПредставлениеДляСекции(СтрСекции) + """" ;
			Node.graphics= Новый Структура;
			Node.graphics.Вставить("type","""roundrectangle""");
			Node.graphics.Вставить("hasFill","0");
			Node.graphics.Вставить("outline","""#0000FF""");
			Node.graphics.Вставить("outlineStyle","""dashed""");
			Node.LabelGraphics= Новый Структура;
			//Node.LabelGraphics.Вставить("fontSize",);
			Node.LabelGraphics.Вставить("anchor","""t""");
			Node.isGroup= "1";
			//Node.Кластер= СтрКластер;
			//Node_GID = Node_ID;
			//Node_ID=Node_ID+1;

	КонецЦикла;
	
	Структура_GML.Вставить("NodeS", NodeS);
	Структура_GML.Вставить("EdgeS", EdgeS);	
	Результат = ЗавершитьПостроениеГрафа(ИдентификаторыФункций, Структура_GML, ТекстГрафа) ;
	Возврат Результат;
	
КонецФункции

Функция ТаблицаВызововПостроениеГрафаВызовыМеждуСекциями(Знач СоответствиеФункций)
	
	Перем ИзСекции, новСтр, Секцию, СтрВызов, ТабВызовы;
	
	ТабВызовы = Новый ТаблицаЗначений;
	ТабВызовы.Колонки.Добавить("ИзСекции",         Новый ОписаниеТипов("Число"));
	ТабВызовы.Колонки.Добавить("Секцию",           Новый ОписаниеТипов("Число"));
	ТабВызовы.Колонки.Добавить("Количество",       Новый ОписаниеТипов("Число"));
	ТабВызовы.Колонки.Добавить("ВложенностьЦикла", Новый ОписаниеТипов("Число"));
	Для Каждого СтрВызов Из Вызовы Цикл
		ИзСекции = СоответствиеФункций.Получить(СтрВызов.ИзФункции);
		Секцию   = СоответствиеФункций.Получить(СтрВызов.Функцию);
		Если (ИзСекции <> Неопределено) И (Секцию <> Неопределено) И (ИзСекции <> Секцию) Тогда
			новСтр = ТабВызовы.Добавить();
			ЗаполнитьЗначенияСвойств(новСтр, СтрВызов);
			новСтр.Секцию   = Секцию;
			новСтр.ИзСекции = ИзСекции;
		КонецЕсли;
	КонецЦикла;
	
	ТабВызовы.Свернуть("ИзСекции,Секцию", "Количество,ВложенностьЦикла");
	Возврат ТабВызовы;

КонецФункции

Функция СписокФункцийПостроениеГрафаВызовыМеждуСекциями(Знач ДеревоФункций)
	
	Перем СоответствиеФункций, СтрСекция, СтрФункция;
	
	СоответствиеФункций = Новый Соответствие;
	Для Каждого СтрСекция Из ДеревоФункций.Строки Цикл
		Для Каждого СтрФункция Из СтрСекция.Строки Цикл
			Если ИсключаемыеФункций.НайтиПоЗначению(СтрФункция.Идентификатор) = Неопределено Тогда
				СоответствиеФункций.Вставить(СтрФункция.Идентификатор, СтрСекция.НомерСекции);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	Возврат СоответствиеФункций;

КонецФункции


Функция ПолучитьПредставлениеДляСекции(СтрСекции)
	
	Возврат "" + СтрСекции.НомерСекции + " - " + СтрСекции.ИмяСекции;
	
КонецФункции


///////////////////////////////////////////////////////////////////////////////
// Рисование графа

Процедура ГрафДобавитьПараметр(Параметры, ИмяСвойства, Значение)
	
	Если Параметры.Свойство(ИмяСвойства) Тогда
		Параметры[ИмяСвойства] = Параметры[ИмяСвойства] + "," + Значение;
	Иначе
		Параметры.Вставить(ИмяСвойства, Значение);
	КонецЕсли;
	
КонецПроцедуры




///////////////////////////////////////////////////////////////////////////////
// ПАРСЕР

Функция РазобратьТекстМодуля(Текст) Экспорт
	
	
	ТекстМодуля = Новый ТекстовыйДокумент;
	ТекстМодуля.ДобавитьСтроку(Текст);
	
	Если РежимОпределенияДиректив82 = 2 Тогда
		// Автоматическое определение
		ДляУправляемойФормы = ЕстьДирективы82ВТексте(ТекстМодуля);
	Иначе
		ДляУправляемойФормы = (РежимОпределенияДиректив82 = 1);
	КонецЕсли;
	
	// --------------------------------------------------------
	// Инициализация
	СтруктураРазбора = ИнициализироватьСтруктуруРазбора(ДляУправляемойФормы);
	
	// --------------------------------------------------------
	// Первый проход
	Результат = ПервыйПроход(ТекстМодуля, ДляУправляемойФормы, СтруктураРазбора);
	Если Результат <> "" Тогда
		Возврат Результат;
	КонецЕсли;
	
	// --------------------------------------------------------
	// Второй проход
	Результат = ВторойПроход(ТекстМодуля, ДляУправляемойФормы, СтруктураРазбора);
	Если Результат <> "" Тогда
		Возврат Результат;
	КонецЕсли;
	
	// --------------------------------------------------------
	// Определим функции приводящие к вызову на сервер
	Если ДляУправляемойФормы Тогда
		ОпределитьФункцииПриводящиеКВызовуНаСервер(СтруктураРазбора);
	КонецЕсли;
	
	// --------------------------------------------------------
	// Вернем результат работы
	ИменаПолейДляКопирования = "Функции,Вызовы,Директивы,Секции,СтрокаПредупреждений,ДляУправляемойФормы";
	Результат = Новый Структура(ИменаПолейДляКопирования);
	ЗаполнитьЗначенияСвойств(Результат, СтруктураРазбора);
	Результат.Вставить("РежимОпределенияДиректив82", РежимОпределенияДиректив82);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьСекции(СтруктураРазбора)
	
	ТабСекции = Новый ТаблицаЗначений;
	ТабСекции.Колонки.Добавить("НомерСекции",        Новый ОписаниеТипов("Число"));
	ТабСекции.Колонки.Добавить("ИмяСекции",          Новый ОписаниеТипов("Строка"));
	ТабСекции.Колонки.Добавить("НомерСтрокиВТексте", Новый ОписаниеТипов("Число"));
	
	СтруктураРазбора.ЗаголовкиСекций.Вставить(0, "<Без секции>");
	
	Для Каждого СтрФ Из СтруктураРазбора.Функции Цикл
		МинНомер = 0;
		Для Каждого Элемент Из СтруктураРазбора.ЗаголовкиСекций Цикл
			Если Элемент.Ключ >= МинНомер И Элемент.Ключ < СтрФ.НомерСтрокиВТексте Тогда
				МинНомер = Элемент.Ключ;
			КонецЕсли;
		КонецЦикла;
		
		НомерСекции = СтруктураРазбора.ЗаголовкиСекций.Получить(МинНомер);
		Если ТипЗнч(НомерСекции) = Тип("Строка") Тогда
			новСтр = ТабСекции.Добавить();
			новСтр.НомерСекции = ТабСекции.Количество();
			новСтр.ИмяСекции = НомерСекции;
			новСтр.НомерСтрокиВТексте = МинНомер;
			
			НомерСекции = новСтр.НомерСекции;
			СтруктураРазбора.ЗаголовкиСекций.Вставить(МинНомер, НомерСекции);
		КонецЕсли;
		СтрФ.НомерСекции = НомерСекции;
	КонецЦикла;
	
	Возврат ТабСекции;
	
КонецФункции

Функция ДобавитьВТаблицуФункции(ИмяФункции, СтруктураРазбора, Директива)
	
	СтруктураРазбора.НомерФункции = СтруктураРазбора.НомерФункции + 1;
	новСтр = СтруктураРазбора.Функции.Добавить();
	новСтр.Идентификатор = "" + Формат(СтруктураРазбора.НомерФункции, "ЧЦ=3; ЧВН=");   //"N" +
	новСтр.ИмяФункции = ИмяФункции;
	новСтр.Директива  = Директива;
	новСтр.ПриводитКВызовуНаСервер = Директива82Серверная(Директива);
	
	Возврат новСтр;
	
КонецФункции

Процедура ДобавитьВТаблицуВызовы(ТабВызовы, ИзФункции, Функцию, Количество, ВложенностьЦикла)
	
	новСтр = ТабВызовы.Добавить();
	новСтр.ИзФункции        = ИзФункции;
	новСтр.Функцию          = Функцию;
	новСтр.Количество       = Количество;
	новСтр.ВложенностьЦикла = ВложенностьЦикла;
	
КонецПроцедуры

Функция ПервыйПроход(ТекстМодуля, ДляУправляемойФормы, СтруктураРазбора)
	
	// 0 - вне функций и процедур
	// 1 - идет поиск закрывающей скобки
	// 2 - идет поиск окончания функции или процедур
	текСостояние = 0;
	
	ЭтоФункция  = Ложь;
	стрОФункции = "";
	новСтр = Неопределено;
	
	Для Сч = 1 По ТекстМодуля.КоличествоСтрок() Цикл
		Стр = ТекстМодуля.ПолучитьСтроку(Сч);
		Если ПустаяСтрока(Стр) Тогда
			Продолжить;
		ИначеЕсли ЯвляетсяКомментарием(Стр, Сч, СтруктураРазбора) Тогда
			Продолжить;
		ИначеЕсли ЯвляетсяДирективой(Стр, СтруктураРазбора, Сч, ДляУправляемойФормы) Тогда
			Продолжить;
		КонецЕсли;
		
		ПервоеСлово = ПолучитьПервоеСлово(Стр, " " + Символы.Таб);
		Если ЯвляетсяФункциейИлиПроцедурой(ПервоеСлово, ЭтоФункция) Тогда
			// Ищем Функция или Процедура
			
			стрФ = ?(ЭтоФункция, "функции", "процедуры");
			Если текСостояние <> 0 Тогда
				Возврат "Не найдено завершение " + стрОФункции + ", в строке " + Сч + " встретилось определение новой " + СтрФ;
			КонецЕсли;
			
			// Получим имя функции
			ИмяФункции = ПолучитьПервоеСлово(Стр, "( " + Символы.Таб);
			Если ПустаяСтрока(ИмяФункции) Тогда
				Возврат "В строке " + Сч + " не найдено имя " + СтрФ;
			КонецЕсли;
			стрОФункции = СтрФ + " " + ИмяФункции;
			
			Директива = ?(СтруктураРазбора.ПоследняяДиректива82 = Неопределено, Директива82ПоУмолчанию(), СтруктураРазбора.ПоследняяДиректива82);
			
			новСтр = ДобавитьВТаблицуФункции(ИмяФункции, СтруктураРазбора, Директива);
			
			новСтр.НомерСтрокиВТексте = Сч;
			новСтр.ЭтоФункция   = ЭтоФункция;
			
			Если ДляУправляемойФормы И СтруктураРазбора.ПоследняяДиректива82 = Неопределено Тогда
				ДобавитьПредупреждение(СтруктураРазбора, Сч, "Для " + стрОФункции + " не указана директива препроцессора 8.2");
			КонецЕсли;
			СтруктураРазбора.ПоследняяДиректива82 = Неопределено;
				
			текСостояние = 1;
			
		ИначеЕсли ЯвляетсяКонцомФункцииИлиПроцедуры(ПервоеСлово, ЭтоФункция) Тогда
			
			Если (текСостояние = 2) И (ЭтоФункция = новСтр.ЭтоФункция) Тогда
				новСтр.Окончание = Сч;
				текСостояние = 0;
			Иначе
				Возврат "Непредвиденное появление " + ПервоеСлово + " в строке " + Сч;
			КонецЕсли;
			
		КонецЕсли;
		
		Если текСостояние = 1 Тогда
			// Ищем закрыващую скобку
			Поз = Найти(Стр, ")");
			Если Поз <> 0 Тогда
				текСостояние = 2;
				Стр = СокрЛП(Сред(Стр, Поз+1));
				Слово = ВРег(ПолучитьПервоеСлово(Стр, " " + Символы.Таб));
				Если Слово = "ЭКСПОРТ" Или Слово = "EXPORT" Тогда
					новСтр.Экспортная = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Если текСостояние Тогда
		Возврат "В конце модуля не найдено завершение " + стрОФункции;
	КонецЕсли;
	
	
	// Разберемся с секциями
	СтруктураРазбора.Вставить("Секции", ПолучитьСекции(СтруктураРазбора));
	
	// Заполним соответствие имен функций и идентификаторов
	Для Каждого СтрФункции Из СтруктураРазбора.Функции Цикл
		СтруктураРазбора.СоответствиеФункций.Вставить(ВРег(СтрФункции.ИмяФункции), СтрФункции.Идентификатор);
	КонецЦикла;

	
	Возврат "";
	
КонецФункции

Функция ВторойПроход(ТекстМодуля, ДляУправляемойФормы, СтруктураРазбора)
	
	масФункций = Новый Массив;
	Для Каждого СтрФункции Из СтруктураРазбора.Функции Цикл
		масФункций.Добавить(СтрФункции);
	КонецЦикла;
	
	Для Каждого СтрФункции Из масФункций Цикл
		ВложенностьЦикла = 0;
		Для СчСтр = СтрФункции.НомерСтрокиВТексте + 1 По СтрФункции.Окончание - 1 Цикл
			Стр = ВРег(СокрЛП(ТекстМодуля.ПолучитьСтроку(СчСтр)));
			Если ПустаяСтрока(Стр) Или Лев(Стр, 2) = "//" Тогда
				Продолжить;
			КонецЕсли;
			
			// Определим вложенность цикла
			ВложенностьЦикла = ВложенностьЦикла + ПодсчитатьЧислоОбращений("ЦИКЛ", Стр, 3)
				+ ПодсчитатьЧислоОбращений("DO", Стр, 3)
				- ПодсчитатьЧислоОбращений("КОНЕЦЦИКЛА", Стр, 3)
				- ПодсчитатьЧислоОбращений("ENDDO", Стр, 3);
			Если ВложенностьЦикла < 0 Тогда
				Возврат "Непредвиденное завершение цикла в строке " + СчСтр;
			КонецЕсли;
			
			
			// Найдем вызовы функций этого же модуля
			Для Каждого Элемент Из СтруктураРазбора.СоответствиеФункций Цикл
				Вызовов = ПодсчитатьЧислоОбращений(Элемент.Ключ, Стр, 1);
				Если Вызовов <> 0 Тогда
					ДобавитьВТаблицуВызовы(СтруктураРазбора.Вызовы, СтрФункции.Идентификатор, Элемент.Значение, Вызовов, ВложенностьЦикла);
				КонецЕсли;
			КонецЦикла;
			
			Если ДляУправляемойФормы И Не Директива82Серверная(СтрФункции.Директива) Тогда
				// Найдем вызовы серверных функций
				Для Каждого Элемент Из СтруктураРазбора.ПриводящиеКВызовуНаСервер Цикл
					Вызовов = ПодсчитатьЧислоОбращений(Элемент.Ключ, Стр, 1);
					Если Вызовов <> 0 Тогда
						ИДФункции = СтруктураРазбора.соотвВызовыНаСервер.Получить(Элемент.Значение);
						Если ИДФункции = Неопределено Тогда
							новСтр = ДобавитьВТаблицуФункции(Элемент.Значение, СтруктураРазбора, Директива82ДляСерверныхФункций());
							ИДФункции = новСтр.Идентификатор;
							СтруктураРазбора.соотвВызовыНаСервер.Вставить(Элемент.Значение, ИДФункции);
						КонецЕсли;
						ДобавитьВТаблицуВызовы(СтруктураРазбора.Вызовы, СтрФункции.Идентификатор, ИДФункции, Вызовов, ВложенностьЦикла);
					КонецЕсли;
				КонецЦикла;
				
				// Найдем обращения к серверным общим модулям
				Для Каждого Элемент Из СтруктураРазбора.ОбщиеМодули Цикл
					Вызовов = ПодсчитатьЧислоОбращений(Элемент.Ключ, Стр, 2);
					Если Вызовов <> 0 Тогда
						ИДФункции = СтруктураРазбора.соотвОбщиеМодули.Получить(Элемент.Значение);
						Если ИДФункции = Неопределено Тогда
							новСтр = ДобавитьВТаблицуФункции(Элемент.Значение, СтруктураРазбора, Директива82ДляСерверныхОбщихМодулей());
							ИДФункции = новСтр.Идентификатор;
							СтруктураРазбора.соотвОбщиеМодули.Вставить(Элемент.Значение, ИДФункции);
						КонецЕсли;
						ДобавитьВТаблицуВызовы(СтруктураРазбора.Вызовы, СтрФункции.Идентификатор, ИДФункции, Вызовов, ВложенностьЦикла);
					КонецЕсли;
				КонецЦикла;
				
			КонецЕсли;
		КонецЦикла;
		
		Если ВложенностьЦикла > 0 Тогда
			Возврат "В функции " + СтрФункции.ИмяФункции + " не найдно завершение цикла";
		КонецЕсли;
	КонецЦикла;
	
	СтруктураРазбора.Вызовы.Свернуть("ИзФункции,Функцию", "Количество,ВложенностьЦикла");

	Возврат "";
	
КонецФункции

Функция ЯвляетсяКомментарием(Стр, НомерСтроки, СтруктураРазбора)
	
	Если ЯвляетсяДлиннымКомментарием(Стр) Тогда
		СтруктураРазбора.ПоследнийДлинныйКомментарий = НомерСтроки;
		Возврат Истина;
	ИначеЕсли Лев(СокрЛП(Стр), 2) <> "//" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если (Лев(Стр, 2) = "//") И (НомерСтроки = СтруктураРазбора.ПоследнийДлинныйКомментарий + 1) Тогда
		Пока Лев(Стр, 1) = "/" Цикл
			Стр = Сред(Стр, 2);
		КонецЦикла;
		Стр = СокрЛП(Стр);
		Если Не ПустаяСтрока(Стр) Тогда
			СтруктураРазбора.ЗаголовкиСекций.Вставить(НомерСтроки, Стр);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция ЯвляетсяДлиннымКомментарием(Стр)
	
	Длина = СтрДлина(Стр);
	Если Длина < 60 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Сч = 1 По Длина Цикл
		Если Сред(Стр, Сч, 1) <> "/" Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ЯвляетсяДирективой(Стр, СтруктураРазбора, НомерСтроки, ДляУправляемойФормы)
	
	Стр = СокрЛП(Стр);
	Если Лев(Стр, 1) = "#" Тогда
		Возврат Истина;
	ИначеЕсли Лев(Стр, 1) <> "&" Тогда
		Возврат Ложь;
	ИначеЕсли Не ДляУправляемойФормы Тогда
		ДобавитьПредупреждение(СтруктураРазбора, НомерСтроки, "Встретилась директива компиляции 8.2: " + Стр);
		Возврат Истина;
	КонецЕсли;
	
	Стр = Сред(Стр, 2);
	Поз = Найти(Стр, "//");
	Если Поз <> 0 Тогда
		Стр = Лев(Стр, Поз-1);
	КонецЕсли;
	Стр = СокрЛП(Стр);
	
	Директива = ПолучитьНомерДирективы82(СтруктураРазбора, ВРег(Стр));
	Если Директива = Неопределено Тогда
		ДобавитьПредупреждение(СтруктураРазбора, НомерСтроки, "Неизвестная директива препроцессора 8.2: " + Стр);
		Директива = Директива82ПоУмолчанию();
	КонецЕсли;
	
	СтруктураРазбора.ПоследняяДиректива82 = Директива;
	
	Возврат Истина;
	
КонецФункции

Процедура ДобавитьПредупреждение(СтруктураРазбора, НомерСтроки, Текст)
	
	Стр = "" + НомерСтроки + ": " + Текст;
	СтруктураРазбора.СтрокаПредупреждений = СтруктураРазбора.СтрокаПредупреждений + Стр + Символы.ПС;
	
КонецПроцедуры

Функция ПолучитьПервоеСлово(Стр, СтрСимволы)
	
	Поз = 0;
	Для Сч = 1 По СтрДлина(СтрСимволы) Цикл
		тПоз = Найти(Стр, Сред(СтрСимволы, Сч, 1));
		Поз  = ?((Поз = 0) Или (тПоз = 0), Макс(Поз, тПоз), Мин(Поз, тПоз));
	КонецЦикла;
	
	Если Поз = 0 Тогда
		Результат = Стр;
		Стр = "";
	Иначе
		Результат = Лев(Стр, Поз-1);
		Стр = СокрЛП(Сред(Стр, Поз + 1));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ЯвляетсяФункциейИлиПроцедурой(Слово, ЭтоФункция)
	
	вСлово = ВРег(Слово);
	Если вСлово = "ФУНКЦИЯ" Или вСлово = "FUNCTION" Тогда
		ЭтоФункция = Истина;
		Возврат Истина;
	ИначеЕсли вСлово = "ПРОЦЕДУРА" Или вСлово = "PROCEDURE" Тогда
		ЭтоФункция = Ложь;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция ЯвляетсяКонцомФункцииИлиПроцедуры(Слово, ЭтоФункция)
	
	вСлово = ВРег(Слово);
	Если вСлово = "КОНЕЦФУНКЦИИ" Или вСлово = "ENDFUNCTION" Тогда
		ЭтоФункция = Истина;
		Возврат Истина;
	ИначеЕсли вСлово = "КОНЕЦПРОЦЕДУРЫ" Или вСлово = "ENDPROCEDURE" Тогда
		ЭтоФункция = Ложь;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция ПодсчитатьЧислоОбращений(ИмяОбращения, СтрокаГдеИщем, ТипПоиска)
	
	Вызовов = 0;
	ДлинаИмени = СтрДлина(ИмяОбращения);
	СтрокаНачало = "";
	СтрокаОкончание = СтрокаГдеИщем;
	
	Пока СтрокаОкончание <> "" Цикл
		Поз = Найти(СтрокаОкончание, ИмяОбращения);
		Если Поз = 0 Тогда
			Прервать;
		КонецЕсли;
		
		СтрокаОкончание = Сред(СтрокаОкончание, ДлинаИмени + Поз);
		
		Если (ТипПоиска = 1) Или (ТипПоиска = 2) Тогда
			// Ищем обращения к функциям или к общим модулям
			ЛС = Лев(СокрЛП(СтрокаОкончание), 1);
			Если ((ЛС = "(") И (ТипПоиска = 1)) Или ((ЛС = ".") И (ТипПоиска = 2))  Тогда
				СтрН = СокрЛП(СтрокаНачало);
				Если ПустаяСтрока(СтрН) Или Найти("=+-*/,;%(", Прав(СтрН, 1)) <> 0 Тогда
					Вызовов = Вызовов + 1;
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли ТипПоиска = 3 Тогда
			// Ищем слова Цикл, КонецЦикла
			ПС = Лев(СтрокаОкончание, 1);
			ЛС = Прав(СтрокаНачало, 1);
			Если ПустаяСтрока(ЛС) И (ПустаяСтрока(ПС) Или ПС = ";") Тогда
				Вызовов = Вызовов + 1;
			КонецЕсли;
						
		Иначе
			ВызватьИсключение("Непредусмотренный тип поиска: " + ТипПоиска);
			
		КонецЕсли;
		
		СтрокаНачало = СтрокаНачало + ДлинаИмени;
		
	КонецЦикла;
	
	Возврат Вызовов;
	
КонецФункции

Процедура ОпределитьФункцииПриводящиеКВызовуНаСервер(СтруктураРазбора)
	
	// Составим список серверных
	соотвСерверные = Новый Соответствие;
	соотвПриводятКВызовуНаСервер = Новый Соответствие;
	Для Каждого СтрФ Из СтруктураРазбора.Функции Цикл
		Если Директива82Серверная(СтрФ.Директива) Тогда
			соотвСерверные.Вставить(СтрФ.Идентификатор, Истина);
			соотвПриводятКВызовуНаСервер.Вставить(СтрФ.Идентификатор, Истина);
		КонецЕсли;
	КонецЦикла;
	
	// Переберем все вызовы и получим полный список функций приводящих к вызову на сервер
	БылиИзменения = Истина;
	Пока БылиИзменения Цикл
		БылиИзменения = Ложь;
		Для Каждого СтрВ Из СтруктураРазбора.Вызовы Цикл
			Если (соотвПриводятКВызовуНаСервер.Получить(СтрВ.Функцию) = Истина) И (соотвПриводятКВызовуНаСервер.Получить(СтрВ.ИзФункции) = Неопределено) Тогда
				соотвПриводятКВызовуНаСервер.Вставить(СтрВ.ИзФункции, Истина);
				БылиИзменения = Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	// Теперь подсчитаем число прямых обращений к серверным функциям из клиентских
	ТабПодсчет = Новый ТаблицаЗначений;
	ТабПодсчет.Колонки.Добавить("Функция",    Новый ОписаниеТипов("Строка"));
	ТабПодсчет.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число"));
	Для Каждого СтрВ Из СтруктураРазбора.Вызовы Цикл
		Если (соотвПриводятКВызовуНаСервер.Получить(СтрВ.ИзФункции) = Истина) 
			И (Не соотвСерверные.Получить(СтрВ.ИзФункции) = Истина) И (соотвСерверные.Получить(СтрВ.Функцию) = Истина) Тогда
			новСтр = ТабПодсчет.Добавить();
			новСтр.Функция = СтрВ.ИзФункции;
			новСтр.Количество = СтрВ.Количество + 2*СтрВ.ВложенностьЦикла;
		КонецЕсли;
	КонецЦикла;
	ТабПодсчет.Свернуть("Функция", "Количество");
	
	соотвПодсчет = Новый Соответствие;
	Для Каждого СтрПодсчет Из ТабПодсчет Цикл
		соотвПодсчет.Вставить(СтрПодсчет.Функция, ?(СтрПодсчет.Количество > 2, 2, СтрПодсчет.Количество));
	КонецЦикла;
	
	// Найдем теперь все проблемные вызовы
	БылиИзменения = Истина;
	Пока БылиИзменения Цикл
		БылиИзменения = Ложь;
		Для Каждого Элемент Из соотвПриводятКВызовуНаСервер Цикл
			ИДФункции = Элемент.Ключ;
			Если соотвСерверные.Получить(ИДФункции) = Истина Тогда
				Продолжить;
			КонецЕсли;
			
			Подсчет = соотвПодсчет.Получить(ИДФункции);
			Если Подсчет = Неопределено Тогда
				Подсчет = 0;
			ИначеЕсли Подсчет >= 2 Тогда
				Продолжить;
			КонецЕсли;
			
			НовоеЗначение = 0;
			СтрокиОбращений = СтруктураРазбора.Вызовы.НайтиСтроки(Новый Структура("ИзФункции", ИДФункции));
			Для Каждого СтрОбращение Из СтрокиОбращений Цикл
				ИДКуда = СтрОбращение.Функцию;
				Если ИДКуда = БылиИзменения Тогда
					// рекурсивный вызов
					НовоеЗначение = 2;
					Прервать;
				КонецЕсли;
				
				ПодсчетОткуда = соотвПодсчет.Получить(ИДКуда);
				Если ПодсчетОткуда <> Неопределено Тогда
					НовоеЗначение = НовоеЗначение + ПодсчетОткуда;
				ИначеЕсли соотвСерверные.Получить(ИДКуда) <> Неопределено Тогда
					НовоеЗначение = НовоеЗначение + СтрОбращение.Количество + 2*СтрОбращение.ВложенностьЦикла;
				КонецЕсли;
			КонецЦикла;
			
			НовоеЗначение = Мин(НовоеЗначение, 2);
			
			Если Подсчет <> НовоеЗначение Тогда
				соотвПодсчет.Вставить(ИДФункции, НовоеЗначение);
				БылиИзменения = Истина;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	// Теперь установим значение флагов
	Для Каждого СтрФ Из СтруктураРазбора.Функции Цикл
		Если соотвПриводятКВызовуНаСервер.Получить(СтрФ.Идентификатор) <> Неопределено Тогда
			СтрФ.ПриводитКВызовуНаСервер = Истина;
		КонецЕсли;
		
		Подсчет = соотвПодсчет.Получить(СтрФ.Идентификатор);
		Если ТипЗнч(Подсчет) = Тип("Число") И Подсчет >= 2 Тогда
			СтрФ.Проблемная82 = Истина;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры



///////////////////////////////////////////////////////////////////////////////
// ИНИЦИАЛИЗАЦИЯ

Функция ИнициализироватьСтруктуруРазбора(ДляУправляемойФормы)
	
	ТабФункции = Новый ТаблицаЗначений;
	ТабФункции.Колонки.Добавить("Идентификатор",                     Новый ОписаниеТипов("Строка"));
	ТабФункции.Колонки.Добавить("ИмяФункции",                        Новый ОписаниеТипов("Строка"));
	ТабФункции.Колонки.Добавить("Директива",                         Новый ОписаниеТипов("Число"));
	ТабФункции.Колонки.Добавить("НомерСтрокиВТексте",                Новый ОписаниеТипов("Число"));
	ТабФункции.Колонки.Добавить("Окончание",                         Новый ОписаниеТипов("Число"));
	ТабФункции.Колонки.Добавить("ЭтоФункция",                        Новый ОписаниеТипов("Булево"));
	ТабФункции.Колонки.Добавить("Экспортная",                        Новый ОписаниеТипов("Булево"));
	ТабФункции.Колонки.Добавить("ПриводитКВызовуНаСервер",           Новый ОписаниеТипов("Булево"));
	ТабФункции.Колонки.Добавить("Проблемная82",                      Новый ОписаниеТипов("Булево"));
	ТабФункции.Колонки.Добавить("НомерСекции",                       Новый ОписаниеТипов("Число"));
	
	ТабВызовы = Новый ТаблицаЗначений;
	ТабВызовы.Колонки.Добавить("ИзФункции");
	ТабВызовы.Колонки.Добавить("Функцию");
	ТабВызовы.Колонки.Добавить("Количество");
	ТабВызовы.Колонки.Добавить("ВложенностьЦикла");
	
	
	СтруктураРазбора = Новый Структура;
	СтруктураРазбора.Вставить("ОбщиеМодули",                 ПолучитьСписокОбщихМодулей(ДляУправляемойФормы));
	СтруктураРазбора.Вставить("ПриводящиеКВызовуНаСервер",   ПолучитьСписокФункцийПриводящихКВызовуНаСервер());
	СтруктураРазбора.Вставить("ПоследнийДлинныйКомментарий", -1);
	СтруктураРазбора.Вставить("ЗаголовкиСекций",             Новый Соответствие);
	СтруктураРазбора.Вставить("ДляУправляемойФормы",         ДляУправляемойФормы);
	СтруктураРазбора.Вставить("ПоследняяДиректива82",        Неопределено);
	СтруктураРазбора.Вставить("НомерФункции",                0);
	СтруктураРазбора.Вставить("Директивы",                   ПолучитьСписокДиректив82());
	СтруктураРазбора.Вставить("СоответствиеФункций",                Новый Соответствие);
	СтруктураРазбора.Вставить("соотвВызовыНаСервер",         Новый Соответствие);
	СтруктураРазбора.Вставить("соотвОбщиеМодули",            Новый Соответствие);
	СтруктураРазбора.Вставить("СтрокаПредупреждений",        "");
	СтруктураРазбора.Вставить("Функции",                     ТабФункции);
	СтруктураРазбора.Вставить("Вызовы",                      ТабВызовы);
	
	Возврат СтруктураРазбора;
	
КонецФункции

Функция ПолучитьСписокОбщихМодулей(ДляУправляемойФормы)
	
	Результат = Новый Соответствие;
	
	Если ДляУправляемойФормы Тогда
		Для Каждого __ОбщийМодуль Из Метаданные.ОбщиеМодули Цикл
			Если Не __ОбщийМодуль.КлиентУправляемоеПриложение И __ОбщийМодуль.Сервер И __ОбщийМодуль.ВызовСервера И Не __ОбщийМодуль.Глобальный Тогда
				Результат.Вставить(ВРег(__ОбщийМодуль.Имя), __ОбщийМодуль.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьСписокФункцийПриводящихКВызовуНаСервер()
	
	Результат = Новый Соответствие;
	ИмяМакета = "Вызовы82ВыполняющиеОбращениеКСерверу";
	Макет = ПолучитьМакет(ИмяМакета);
	Для Сч = 1 По Макет.КоличествоСтрок() Цикл
		Стр = СокрЛП(Макет.ПолучитьСтроку(Сч));
		Если ПустаяСтрока(Стр) Тогда
			Продолжить;
		КонецЕсли;
		
		Поз = Найти(Стр, " ");
		Если Поз = 0 Тогда
			ВызватьИсключение("Не верный формат строки " + Сч + " в макете " + ИмяМакета);
		КонецЕсли;
		
		ДобавитьДляПоиска(Результат, Лев(Стр, Поз-1), СокрЛП(Сред(Стр, Поз+1)));
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ДобавитьДляПоиска(Куда, РусскийВариант, АнглийскийВариант)
	
	Куда.Вставить(ВРег(РусскийВариант),    РусскийВариант);
	Куда.Вставить(ВРег(АнглийскийВариант), РусскийВариант);
	
КонецПроцедуры


///////////////////////////////////////////////////////////////////////////////
// ДИРЕКТИВЫ 8.2

Функция ПолучитьСписокДиректив82()
	
	ТабДирективы = Новый ТаблицаЗначений;
	ТабДирективы.Колонки.Добавить("НомерДирективы");
	ТабДирективы.Колонки.Добавить("ОписаниеДирективы");
	ТабДирективы.Колонки.Добавить("ОстанавливатьПоиск");
	ТабДирективы.Колонки.Добавить("ПоРусскиВРЕГ");
	ТабДирективы.Колонки.Добавить("ПоАнглийскиВРЕГ");
	
	ДобавитьДирективу82(ТабДирективы, 1,   Ложь, "НаКлиенте",                      "AtClient");
	ДобавитьДирективу82(ТабДирективы, 2, Истина, "НаСервере",                      "AtServer");
	ДобавитьДирективу82(ТабДирективы, 3, Истина, "НаСервереБезКонтекста",          "AtServerNoContext");
	ДобавитьДирективу82(ТабДирективы, 4,   Ложь, "НаКлиентеНаСервереБезКонтекста", "AtClientAtServerNoContext");
	ДобавитьДирективу82(ТабДирективы, 5,   Ложь, "НаКлиентеНаСервере",             "AtClientAtServer");
	ДобавитьДирективу82(ТабДирективы, 6, Истина, "Серверные функции",              "");
	ДобавитьДирективу82(ТабДирективы, 7, Истина, "Серверные общие модули",         "");
	
	Возврат ТабДирективы;
	
КонецФункции

Функция Директива82ПоУмолчанию()
	
	// НаСервере
	Возврат 2;
	
КонецФункции

Функция Директива82ДляСерверныхФункций()
	
	Возврат 6;
	
КонецФункции

Функция Директива82ДляСерверныхОбщихМодулей()
	
	Возврат 7;
	
КонецФункции

Функция Директива82Серверная(НомерДирективы)
	
	Возврат (НомерДирективы <> 1) И (НомерДирективы <> 4) И (НомерДирективы <> 5);
	
КонецФункции

Функция ПолучитьНомерДирективы82(СтруктураРазбора, Стр)
	
	Для Каждого СтрД Из СтруктураРазбора.Директивы Цикл
		Если Не ПустаяСтрока(СтрД.ПоАнглийскиВРЕГ) И ((СтрД.ПоРусскиВРЕГ = Стр) Или (СтрД.ПоАнглийскиВРЕГ = Стр)) Тогда
			Возврат СтрД.НомерДирективы;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Процедура ДобавитьДирективу82(ТаблицаДиректив, НомерДирективы, ОстанавливатьПоиск, ПоРусски, ПоАнглийски)
	
	новСтр = ТаблицаДиректив.Добавить();
	новСтр.НомерДирективы     = НомерДирективы;
	новСтр.ОстанавливатьПоиск = ОстанавливатьПоиск;
	Если Не ПустаяСтрока(ПоАнглийски) Тогда
		новСтр.ОписаниеДирективы  = "&" + ПоРусски;
		новСтр.ПоРусскиВРЕГ       = ВРег(ПоРусски);
		новСтр.ПоАнглийскиВРЕГ    = ВРег(ПоАнглийски);
	Иначе
		новСтр.ОписаниеДирективы  = ПоРусски;
	КонецЕсли;
	
КонецПроцедуры

Функция ЕстьДирективы82ВТексте(ТекстМодуля)
	
	Для Сч = 1 По ТекстМодуля.КоличествоСтрок() Цикл
		Стр = СокрЛП(ТекстМодуля.ПолучитьСтроку(Сч));
		Если Лев(Стр, 1) = "&" Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции


